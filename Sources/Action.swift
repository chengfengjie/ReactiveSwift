import Dispatch
import Foundation
import enum Result.NoError

/// Represents an action that will do some work when executed with a value of
/// type `Input`, then return zero or more values of type `Output` and/or fail
/// with an error of type `Error`. If no failure should be possible, NoError can
/// be specified for the `Error` parameter.
///
/// Actions enforce serial execution. Any attempt to execute an action multiple
/// times concurrently will return an error.
public final class Action<Input, Output, Error: Swift.Error> {
	private let deinitToken: Lifetime.Token

	private let executeClosure: (Input) -> SignalProducer<Output, ActionError<Error>>
	private let eventsObserver: Signal<Event<Output, Error>, NoError>.Observer
	private let disabledErrorsObserver: Signal<(), NoError>.Observer

	/// The lifetime of the Action.
	public let lifetime: Lifetime

	/// A signal of all events generated from applications of the Action.
	///
	/// In other words, this will send every `Event` from every signal generated
	/// by each SignalProducer returned from apply() except `ActionError.disabled`.
	public let events: Signal<Event<Output, Error>, NoError>

	/// A signal of all values generated from applications of the Action.
	///
	/// In other words, this will send every value from every signal generated
	/// by each SignalProducer returned from apply() except `ActionError.disabled`.
	public let values: Signal<Output, NoError>

	/// A signal of all errors generated from applications of the Action.
	///
	/// In other words, this will send errors from every signal generated by
	/// each SignalProducer returned from apply() except `ActionError.disabled`.
	public let errors: Signal<Error, NoError>

	/// A signal which is triggered by `ActionError.disabled`.
	public let disabledErrors: Signal<(), NoError>

	/// A signal of all completed events generated from applications of the action.
	///
	/// In other words, this will send completed events from every signal generated
	/// by each SignalProducer returned from apply().
	public let completed: Signal<(), NoError>

	/// Whether the action is currently executing.
	public let isExecuting: Property<Bool>

	/// Whether the action is currently enabled.
	public let isEnabled: Property<Bool>

	private let state: MutableProperty<ActionState>

	/// Initializes an action that will be conditionally enabled, and creates a
	/// SignalProducer for each input.
	///
	/// - warning: This is an internal implementation detail of `Action.init(input:_:)`
	///            and will be removed in a future version of ReactiveSwift.
	///            Use `Action.init(enabledIf:_:)` instead.
	///
	/// - parameters:
	///   - enabledIf: Boolean property that shows whether the action is
	///                enabled.
	///   - execute: A closure that returns the signal producer returned by
	///              calling `apply(Input)` on the action.
	public init<P: PropertyProtocol>(_internalEnabledIf property: P, tryExecute: @escaping (Input) -> SignalProducer<Output, ActionError<Error>>) where P.Value == Bool {
		deinitToken = Lifetime.Token()
		lifetime = Lifetime(deinitToken)

		executeClosure = tryExecute

		(events, eventsObserver) = Signal<Event<Output, Error>, NoError>.pipe()
		(disabledErrors, disabledErrorsObserver) = Signal<(), NoError>.pipe()

		values = events.map { $0.value }.skipNil()
		errors = events.map { $0.error }.skipNil()
		completed = events.filter { $0.isCompleted }.map { _ in }

		state = MutableProperty(ActionState(isExecuting: false, userEnabled: property.value))

		property.signal
			.take(during: state.lifetime)
			.observeValues { [weak state] isEnabled in
				state?.modify {
					$0.userEnabled = isEnabled
				}
			}

		isEnabled = state.map { $0.isEnabled }
		isExecuting = state.map { $0.isExecuting }
	}

	/// Initializes an action that will be conditionally enabled, and creates a
	/// SignalProducer for each input.
	///
	/// - parameters:
	///   - enabledIf: Boolean property that shows whether the action is
	///                enabled.
	///   - execute: A closure that returns the signal producer returned by
	///              calling `apply(Input)` on the action.
	public convenience init<P: PropertyProtocol>(enabledIf property: P, _ execute: @escaping (Input) -> SignalProducer<Output, Error>) where P.Value == Bool {
		self.init(_internalEnabledIf: property) {
			execute($0).mapError(ActionError.producerFailed)
		}
	}

	/// Initializes an action that will be enabled by default, and creates a
	/// SignalProducer for each input.
	///
	/// - parameters:
	///   - execute: A closure that returns the signal producer returned by
	///              calling `apply(Input)` on the action.
	public convenience init(_ execute: @escaping (Input) -> SignalProducer<Output, Error>) {
		self.init(enabledIf: Property(value: true), execute)
	}

	deinit {
		eventsObserver.sendCompleted()
		disabledErrorsObserver.sendCompleted()
	}

	/// Creates a SignalProducer that, when started, will execute the action
	/// with the given input, then forward the results upon the produced Signal.
	///
	/// - note: If the action is disabled when the returned SignalProducer is
	///         started, the produced signal will send `ActionError.disabled`,
	///         and nothing will be sent upon `values` or `errors` for that
	///         particular signal.
	///
	/// - parameters:
	///   - input: A value that will be passed to the closure creating the signal
	///            producer.
	public func apply(_ input: Input) -> SignalProducer<Output, ActionError<Error>> {
		return SignalProducer { observer, disposable in
			let startedExecuting = self.state.modify { state -> Bool in
				if state.isEnabled {
					state.isExecuting = true
					return true
				} else {
					return false
				}
			}

			guard startedExecuting else {
				observer.send(error: .disabled)
				self.disabledErrorsObserver.send(value: ())
				return
			}

			self.executeClosure(input).startWithSignal { signal, signalDisposable in
				disposable += signalDisposable

				signal.observe { event in
					observer.action(event)

					switch event {
					case .failed(.disabled):
						self.disabledErrorsObserver.send(value: ())
					case let .failed(.producerFailed(error)):
						self.eventsObserver.send(value: .failed(error))
					case let .value(value):
						self.eventsObserver.send(value: .value(value))
					case .completed:
						self.eventsObserver.send(value: .completed)
					case .interrupted:
						self.eventsObserver.send(value: .interrupted)
					}
				}
			}

			disposable += {
				self.state.modify {
					$0.isExecuting = false
				}
			}
		}
	}
}

private struct ActionState {
	var isExecuting: Bool
	var userEnabled: Bool

	/// Whether the action should be enabled for the given combination of user
	/// enabledness and executing status.
	fileprivate var isEnabled: Bool {
		return userEnabled && !isExecuting
	}
}

public protocol ActionProtocol: BindingTargetProtocol {
	/// The type of argument to apply the action to.
	associatedtype Input
	/// The type of values returned by the action.
	associatedtype Output
	/// The type of error when the action fails. If errors aren't possible then
	/// `NoError` can be used.
	associatedtype Error: Swift.Error

	/// Initializes an action that will be conditionally enabled, and creates a
	/// SignalProducer for each input.
	///
	/// - warning: This is an internal implementation detail of `Action.init(input:_:)`
	///            and will be removed in a future version of ReactiveSwift.
	///            Use `Action.init(enabledIf:_:)` instead.
	///
	/// - parameters:
	///   - enabledIf: Boolean property that shows whether the action is
	///                enabled.
	///   - execute: A closure that returns the signal producer returned by
	///              calling `apply(Input)` on the action.
	init<P: PropertyProtocol>(_internalEnabledIf property: P, tryExecute: @escaping (Input) -> SignalProducer<Output, ActionError<Error>>) where P.Value == Bool

	/// Whether the action is currently enabled.
	var isEnabled: Property<Bool> { get }

	/// Extracts an action from the receiver.
	var action: Action<Input, Output, Error> { get }

	/// Creates a SignalProducer that, when started, will execute the action
	/// with the given input, then forward the results upon the produced Signal.
	///
	/// - note: If the action is disabled when the returned SignalProducer is
	///         started, the produced signal will send `ActionError.disabled`,
	///         and nothing will be sent upon `values` or `errors` for that
	///         particular signal.
	///
	/// - parameters:
	///   - input: A value that will be passed to the closure creating the signal
	///            producer.
	func apply(_ input: Input) -> SignalProducer<Output, ActionError<Error>>
}

extension ActionProtocol {
	public func consume(_ value: Input) {
		apply(value).start()
	}
}

extension Action: ActionProtocol {
	public var action: Action {
		return self
	}
}

extension ActionProtocol where Input == Void {
	/// Initializes an action that uses an optional property for its input,
	/// and is disabled whenever the input is nil. When executed, a SignalProducer
	/// is created with the current value of the input.
	///
	/// - parameters:
	///   - input: An Optional property whose current value is used as input
	///            whenever the action is executed. The action is disabled
	///            whenever the value is nil.
	///   - execute: A closure to return a new SignalProducer based on the
	///              current value of `input`.
	public init<P: PropertyProtocol, T>(input: P, _ execute: @escaping (T) -> SignalProducer<Output, Error>) where P.Value == T? {
		self.init(_internalEnabledIf: input.map { $0 != nil }) {
			guard let input = input.value else { return SignalProducer(error: .disabled) }
			return execute(input).mapError(ActionError.producerFailed)
		}
	}

	/// Initializes an action that uses a property for its input. When executed,
	/// a SignalProducer is created with the current value of the input.
	///
	/// - parameters:
	///   - input: A property whose current value is used as input
	///            whenever the action is executed.
	///   - execute: A closure to return a new SignalProducer based on the
	///              current value of `input`.
	public init<P: PropertyProtocol, T>(input: P, _ execute: @escaping (T) -> SignalProducer<Output, Error>) where P.Value == T {
		self.init(input: input.map(Optional.some), execute)
	}
}

/// The type of error that can occur from Action.apply, where `Error` is the
/// type of error that can be generated by the specific Action instance.
public enum ActionError<Error: Swift.Error>: Swift.Error {
	/// The producer returned from apply() was started while the Action was
	/// disabled.
	case disabled

	/// The producer returned from apply() sent the given error.
	case producerFailed(Error)
}

public func == <Error: Equatable>(lhs: ActionError<Error>, rhs: ActionError<Error>) -> Bool {
	switch (lhs, rhs) {
	case (.disabled, .disabled):
		return true

	case let (.producerFailed(left), .producerFailed(right)):
		return left == right

	default:
		return false
	}
}
